from common import xor, split_blocks, join_blocks, pad_pkcs7, unpad_pkcs7
import time


class OracleError(Exception):
    pass


class CBCPaddingOracle:
    def query(self, ciphertext):
        raise NotImplementedError


class CBCOraclePwner:
    def __init__(self, oracle, block_size=16, verbose=True, nesting_level=1):
        self.oracle = oracle
        self.block_size = block_size
        self.verbose = verbose
        self.nesting_level = nesting_level

    def decrypt_block(self, prev_blocks, block):
        assert len(block) == self.block_size
        assert len(prev_blocks) == self.nesting_level * self.block_size
        if self.verbose:
            print("[+] decrypting block {}".format(block))
        solutions = [0]*self.block_size
        for num_solved in range(self.block_size):
            pad_byte = num_solved + 1
            tamp_ct = bytearray(prev_blocks + block)
            for i in range(num_solved):
                idx = self.block_size - 1 - i
                solution = solutions[idx]
                tamp_ct[idx] = prev_blocks[:self.block_size][idx] ^ solution ^ pad_byte
            for guess in range(256):
                #  print("[*] guess {}".format(guess))
                idx = self.block_size - 1 - num_solved
                tamp_ct[idx] = prev_blocks[:self.block_size][idx] ^ guess ^ pad_byte
                if not self.oracle.query(tamp_ct):
                    time.sleep(0.02)
                    continue
                is_correct_guess = num_solved != 0
                if not is_correct_guess:
                    tamp_ct[idx-1] ^= 0xff
                    if self.oracle.query(tamp_ct):
                        is_correct_guess = True
                    tamp_ct[idx-1] ^= 0xff
                if is_correct_guess:
                    solutions[-(num_solved+1)] = guess
                    if self.verbose:
                        print("[+] decrypted byte {}".format(bytes([guess])))
                    break
            else:
                raise OracleError('No guess was correct.')
        solutions = bytes(solutions)
        if self.verbose:
            print("[+] decoded block {}".format(solutions))
        return solutions

    def decrypt_msg(self, ciphertext):
        assert len(ciphertext) % self.block_size == 0
        assert len(ciphertext) > self.nesting_level * self.block_size
        blocks = split_blocks(ciphertext, self.block_size)
        print("num blocks: {}".format(len(blocks)))
        plaintext = join_blocks(
                self.decrypt_block(b''.join(blocks[i:i+self.nesting_level]), blocks[i+self.nesting_level])
                for i in range(len(blocks) - self.nesting_level)
            )
        print("[+] decrypted message: {}".format(plaintext))
        return plaintext

    def decrypt_unpad_msg(self, ciphertext):
        padded_msg = self.decrypt_msg(ciphertext)
        return unpad_pkcs7(padded_msg)

    def encrypt_block(self, plaintext, ciphertext_blocks):
        if self.verbose:
            print("[+] encrypting block {}".format(plaintext))
        ivs = [b'\x41'*self.block_size] + ciphertext_blocks[:-1]
        print("ivs: {}".format(ivs))
        decrypted = self.decrypt_block(b''.join(ivs), ciphertext_blocks[-1])
        ivs[0] = xor(xor(plaintext, decrypted), ivs[0])
        return ivs[0]

    def encrypt_msg(self, plaintext):
        p_blocks = split_blocks(plaintext, self.block_size)
        c_blocks = [b'\x42'*self.block_size] * self.nesting_level
        for block in reversed(p_blocks):
            print("c_blocks: {}".format(c_blocks))
            iv = self.encrypt_block(block, c_blocks[-self.nesting_level:][::-1])
            c_blocks.append(iv)
        return join_blocks(reversed(c_blocks))

    def encrypt_pad_msg(self, plaintext):
        padded_msg = pad_pkcs7(plaintext, self.block_size)
        return self.encrypt_msg(padded_msg)
